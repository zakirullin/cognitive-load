# Cognitive load má»›i lÃ  thá»© quan trá»ng

[Prompt](https://github.com/zakirullin/cognitive-load/blob/main/README.prompt.md) | [Blog version](https://minds.md/zakirullin/cognitive) | [Chinese](https://github.com/zakirullin/cognitive-load/blob/main/README.zh-cn.md) | [Korean](README.ko.md) | [Turkish](README.tr.md) | [Japanese](README.ja.md) | [Vietnamese](README.vi.md)

*ÄÃ¢y lÃ  tÃ i liá»‡u sá»‘ng, cáº­p nháº­t láº§n cuá»‘i: **ThÃ¡ng 10/2025.** Má»i Ä‘Ã³ng gÃ³p Ä‘á»u Ä‘Æ°á»£c chÃ o Ä‘Ã³n!*

## Giá»›i thiá»‡u
CÃ³ quÃ¡ nhiá»u buzzword vÃ  best practice ngoÃ i kia, nhÆ°ng pháº§n lá»›n Ä‘á»u tháº¥t báº¡i. ChÃºng tháº¥t báº¡i vÃ¬ chÃºng Ä‘Æ°á»£c tÆ°á»Ÿng tÆ°á»£ng ra, khÃ´ng pháº£i thá»±c táº¿. Nhá»¯ng Ã½ tÆ°á»Ÿng nÃ y dá»±a trÃªn tháº©m má»¹ vÃ  Ä‘Ã¡nh giÃ¡ chá»§ quan. ChÃºng ta cáº§n thá»© gÃ¬ Ä‘Ã³ fundamental hÆ¡n, thá»© khÃ´ng thá»ƒ sai Ä‘Æ°á»£c.

ÄÃ´i khi chÃºng ta cáº£m tháº¥y bá»‘i rá»‘i khi Ä‘á»c code. Sá»± bá»‘i rá»‘i tá»‘n thá»i gian vÃ  tiá»n báº¡c. Sá»± bá»‘i rá»‘i Ä‘Æ°á»£c gÃ¢y ra bá»Ÿi *cognitive load* cao. ÄÃ¢y khÃ´ng pháº£i má»™t khÃ¡i niá»‡m trá»«u tÆ°á»£ng fancy, mÃ  lÃ  **má»™t giá»›i háº¡n cÆ¡ báº£n cá»§a con ngÆ°á»i.** NÃ³ khÃ´ng pháº£i tÆ°á»Ÿng tÆ°á»£ng, nÃ³ á»Ÿ Ä‘Ã³ vÃ  chÃºng ta cáº£m nháº­n Ä‘Æ°á»£c.

VÃ¬ chÃºng ta dÃ nh nhiá»u thá»i gian Ä‘á»c vÃ  hiá»ƒu code hÆ¡n lÃ  viáº¿t nÃ³, chÃºng ta nÃªn liÃªn tá»¥c tá»± há»i liá»‡u mÃ¬nh cÃ³ Ä‘ang nhÃ©t quÃ¡ nhiá»u cognitive load vÃ o code hay khÃ´ng.

## Cognitive load
> Cognitive load lÃ  lÆ°á»£ng suy nghÄ© mÃ  má»™t developer cáº§n Ä‘á»ƒ hoÃ n thÃ nh má»™t task.

Khi Ä‘á»c code, báº¡n Ä‘Æ°a cÃ¡c thá»© nhÆ° giÃ¡ trá»‹ biáº¿n, control flow logic vÃ  call sequence vÃ o Ä‘áº§u. Má»™t ngÆ°á»i bÃ¬nh thÆ°á»ng cÃ³ thá»ƒ giá»¯ khoáº£ng [bá»‘n chunk nhÆ° váº­y](https://github.com/zakirullin/cognitive-load/issues/16) trong working memory. Khi cognitive load Ä‘áº¡t ngÆ°á»¡ng nÃ y, viá»‡c hiá»ƒu trá»Ÿ nÃªn khÃ³ khÄƒn hÆ¡n nhiá»u.

*Giáº£ sá»­ chÃºng ta Ä‘Æ°á»£c yÃªu cáº§u fix bug cho má»™t project hoÃ n toÃ n xa láº¡. NgÆ°á»i ta nÃ³i cÃ³ má»™t developer thÃ´ng minh Ä‘Ã£ contribute vÃ o Ä‘Ã³. Nhiá»u kiáº¿n trÃºc xá»‹n, library fancy vÃ  cÃ´ng nghá»‡ trendy Ä‘Æ°á»£c sá»­ dá»¥ng. NÃ³i cÃ¡ch khÃ¡c, **tÃ¡c giáº£ Ä‘Ã£ táº¡o ra cognitive load cao cho chÃºng ta.***

<div align="center">
  <img src="/img/cognitiveloadv6.png" alt="Cognitive load" width="750">
</div>

ChÃºng ta nÃªn giáº£m cognitive load trong project cÃ ng nhiá»u cÃ ng tá»‘t.

<details>
  <summary><b>Cognitive load vÃ  interruption</b></summary>
  <div align="center">
    <img src="img/interruption.jpeg" width="480">
  </div>
</details>

> ChÃºng ta sáº½ dÃ¹ng "cognitive load" theo nghÄ©a informal; Ä‘Ã´i khi nÃ³ khá»›p vá»›i khÃ¡i niá»‡m khoa há»c vá» Cognitive Load, nhÆ°ng chÃºng ta khÃ´ng biáº¿t chÃ­nh xÃ¡c chá»— nÃ o khá»›p vÃ  chá»— nÃ o khÃ´ng.

## CÃ¡c loáº¡i cognitive load
**Intrinsic** - do Ä‘á»™ khÃ³ vá»‘n cÃ³ cá»§a task gÃ¢y ra. KhÃ´ng thá»ƒ giáº£m Ä‘Æ°á»£c, nÃ³ náº±m trong báº£n cháº¥t cá»§a software development.

**Extraneous** - do cÃ¡ch trÃ¬nh bÃ y thÃ´ng tin táº¡o ra. Do cÃ¡c yáº¿u tá»‘ khÃ´ng liÃªn quan trá»±c tiáº¿p Ä‘áº¿n task, nhÆ° thÃ³i quen cá»§a tÃ¡c giáº£ thÃ´ng minh. CÃ³ thá»ƒ giáº£m Ä‘Ã¡ng ká»ƒ. ChÃºng ta sáº½ táº­p trung vÃ o loáº¡i cognitive load nÃ y.

<div align="center">
  <img src="/img/smartauthorv14thanksmari.png" alt="Intrinsic vs Extraneous" width="600">
</div>

CÃ¹ng nháº£y tháº³ng vÃ o cÃ¡c vÃ­ dá»¥ thá»±c táº¿ cá»¥ thá»ƒ vá» extraneous cognitive load.

---

ChÃºng ta sáº½ gá»i level cá»§a cognitive load nhÆ° sau:
`ğŸ§ `: working memory trong lÃ nh, zero cognitive load
`ğŸ§ ++`: hai fact trong working memory, cognitive load tÄƒng
`ğŸ¤¯`: cognitive overload, hÆ¡n 4 fact

> NÃ£o bá»™ chÃºng ta phá»©c táº¡p vÃ  chÆ°a Ä‘Æ°á»£c khÃ¡m phÃ¡ nhiá»u hÆ¡n tháº¿, nhÆ°ng ta cÃ³ thá»ƒ dÃ¹ng model Ä‘Æ¡n giáº£n nÃ y.

## Conditional phá»©c táº¡p
```go
if val > someConstant // ğŸ§ +
    && (condition2 || condition3) // ğŸ§ +++, prev cond pháº£i true, má»™t trong c2 hoáº·c c3 pháº£i true
    && (condition4 && !condition5) { // ğŸ¤¯, tá»›i Ä‘Ã¢y ta Ä‘Ã£ rá»‘i
    ...
}
```

ÄÆ°a vÃ o cÃ¡c biáº¿n trung gian vá»›i tÃªn cÃ³ nghÄ©a:
```go
isValid = val > someConstant
isAllowed = condition2 || condition3
isSecure = condition4 && !condition5
// ğŸ§ , khÃ´ng cáº§n nhá»› cÃ¡c condition, cÃ³ biáº¿n mÃ´ táº£ rá»“i
if isValid && isAllowed && isSecure {
    ...
}
```

## Nested if
```go
if isValid { // ğŸ§ +, okay code nested chá»‰ apply cho valid input
    if isSecure { // ğŸ§ ++, ta chá»‰ lÃ m stuff cho valid vÃ  secure input
        stuff // ğŸ§ +++
    }
}
```

So sÃ¡nh vá»›i early return:
```go
if !isValid
    return

if !isSecure
    return

// ğŸ§ , ta khÃ´ng quan tÃ¢m early return á»Ÿ trÃªn, náº¿u tá»›i Ä‘Ã¢y thÃ¬ má»i thá»© OK

stuff // ğŸ§ +
```

Ta cÃ³ thá»ƒ focus vÃ o happy path thÃ´i, giáº£i phÃ³ng working memory khá»i cÃ¡c precondition.

## Ãc má»™ng káº¿ thá»«a
Ta Ä‘Æ°á»£c yÃªu cáº§u thay Ä‘á»•i vÃ i thá»© cho admin user: `ğŸ§ `

`AdminController extends UserController extends GuestController extends BaseController`

á»’, má»™t pháº§n functionality náº±m trong `BaseController`, coi thá»­: `ğŸ§ +`
Role mechanic cÆ¡ báº£n Ä‘Æ°á»£c giá»›i thiá»‡u trong `GuestController`: `ğŸ§ ++`
Má»i thá»© Ä‘Æ°á»£c thay Ä‘á»•i má»™t pháº§n trong `UserController`: `ğŸ§ +++`
Cuá»‘i cÃ¹ng tá»›i Ä‘Ã¢y, `AdminController`, code thÃ´i! `ğŸ§ ++++`

Ã€ Ä‘á»£i, cÃ²n cÃ³ `SuperuserController` extend `AdminController`. Náº¿u sá»­a `AdminController` ta cÃ³ thá»ƒ lÃ m há»ng class káº¿ thá»«a, nÃªn xem `SuperuserController` trÆ°á»›c: `ğŸ¤¯`

Æ¯u tiÃªn composition hÆ¡n inheritance. Ta sáº½ khÃ´ng Ä‘i sÃ¢u - cÃ³ [ráº¥t nhiá»u tÃ i liá»‡u](https://www.youtube.com/watch?v=hxGOiiR9ZKg) vá» viá»‡c nÃ y.

## QuÃ¡ nhiá»u method, class hoáº·c module nhá»
> Method, class vÃ  module cÃ³ thá»ƒ thay tháº¿ cho nhau trong context nÃ y.

CÃ¡c mantra kiá»ƒu "method nÃªn ngáº¯n hÆ¡n 15 dÃ²ng code" hay "class nÃªn nhá»" hÃ³a ra hÆ¡i sai.

**Deep module** - interface Ä‘Æ¡n giáº£n, functionality phá»©c táº¡p
**Shallow module** - interface tÆ°Æ¡ng Ä‘á»‘i phá»©c táº¡p so vá»›i functionality nhá» mÃ  nÃ³ cung cáº¥p

<div align="center">
  <img src="/img/deepmodulev8.png" alt="Deep module" width="700">
</div>

CÃ³ quÃ¡ nhiá»u shallow module cÃ³ thá»ƒ gÃ¢y khÃ³ khÄƒn cho viá»‡c hiá»ƒu project. **KhÃ´ng chá»‰ pháº£i nhá»› responsibility cá»§a tá»«ng module, mÃ  cÃ²n pháº£i nhá»› táº¥t cáº£ interaction giá»¯a chÃºng.** Äá»ƒ hiá»ƒu má»¥c Ä‘Ã­ch cá»§a shallow module, trÆ°á»›c tiÃªn ta pháº£i xem functionality cá»§a cÃ¡c module liÃªn quan. Nháº£y giá»¯a cÃ¡c component shallow nhÆ° váº­y ráº¥t má»‡t má»i vá» máº·t tinh tháº§n, <a target="_blank" href="https://blog.separateconcerns.com/2023-09-11-linear-code.html">linear thinking</a> tá»± nhiÃªn hÆ¡n vá»›i con ngÆ°á»i.

> Information hiding lÃ  tá»‘i quan trá»ng, vÃ  ta khÃ´ng áº©n Ä‘Æ°á»£c nhiá»u complexity trong shallow module.

TÃ´i cÃ³ hai pet project, cáº£ hai Ä‘á»u khoáº£ng 5K dÃ²ng code. Project Ä‘áº§u cÃ³ 80 shallow class, trong khi project thá»© hai chá»‰ cÃ³ 7 deep class. TÃ´i khÃ´ng maintain hai project nÃ y trong má»™t nÄƒm rÆ°á»¡i.

Khi quay láº¡i, tÃ´i nháº­n ra ráº±ng cá»±c ká»³ khÃ³ Ä‘á»ƒ tÃ¡ch rÃµ táº¥t cáº£ interaction giá»¯a 80 class trong project Ä‘áº§u. TÃ´i pháº£i rebuild má»™t lÆ°á»£ng cognitive load khá»•ng lá»“ trÆ°á»›c khi cÃ³ thá»ƒ báº¯t Ä‘áº§u code. Máº·t khÃ¡c, tÃ´i cÃ³ thá»ƒ náº¯m báº¯t project thá»© hai nhanh chÃ³ng vÃ¬ nÃ³ chá»‰ cÃ³ vÃ i deep class vá»›i interface Ä‘Æ¡n giáº£n.

> Component tá»‘t nháº¥t lÃ  nhá»¯ng component cung cáº¥p functionality máº¡nh máº½ nhÆ°ng cÃ³ interface Ä‘Æ¡n giáº£n.
>
> *John Ousterhout, A Philosophy of Software Design*

Interface cá»§a Unix I/O ráº¥t Ä‘Æ¡n giáº£n. NÃ³ chá»‰ cÃ³ nÄƒm basic call:
```python
open(path, flags, permissions)
read(fd, buffer, count)
write(fd, buffer, count)
lseek(fd, offset, referencePosition)
close(fd)
```

Implementation hiá»‡n Ä‘áº¡i cá»§a interface nÃ y cÃ³ **hÃ ng trÄƒm nghÃ¬n dÃ²ng code.** Ráº¥t nhiá»u complexity Ä‘Æ°á»£c áº©n bÃªn dÆ°á»›i. NhÆ°ng nÃ³ dá»… dÃ¹ng nhá» interface Ä‘Æ¡n giáº£n.

> VÃ­ dá»¥ deep module nÃ y Ä‘Æ°á»£c láº¥y tá»« sÃ¡ch [A Philosophy of Software Design](https://web.stanford.edu/~ouster/cgi-bin/book.php) cá»§a John Ousterhout. KhÃ´ng chá»‰ cuá»‘n sÃ¡ch nÃ y bÃ n vá» báº£n cháº¥t cá»§a complexity trong software development, mÃ  cÃ²n cÃ³ cÃ¡ch giáº£i thÃ­ch hay nháº¥t vá» paper cÃ³ áº£nh hÆ°á»Ÿng cá»§a Parnas [On the Criteria To Be Used in Decomposing Systems into Modules](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf). Cáº£ hai Ä‘á»u lÃ  tÃ i liá»‡u báº¯t buá»™c pháº£i Ä‘á»c. CÃ¡c tÃ i liá»‡u liÃªn quan khÃ¡c: [A Philosophy of Software Design vs Clean Code](https://github.com/johnousterhout/aposd-vs-clean-code), [It's probably time to stop recommending Clean Code](https://qntm.org/clean), [Small Functions considered Harmful](https://copyconstruct.medium.com/small-functions-considered-harmful-91035d316c29).

<details>
    <summary><b>Nhá»¯ng thá»© quan trá»ng nÃªn to, vÃ­ dá»¥</b></summary>
    <br>
    <div align="center">
        <img src="/img/dirty.png" alt="Clean vs Dirty" width="600">
    </div>
    <blockquote>Náº¿u báº¡n cho phÃ©p cÃ¡c function "crux" quan trá»ng to hÆ¡n ("dirty"), sáº½ dá»… dÃ ng hÆ¡n Ä‘á»ƒ pick chÃºng ra khá»i biá»ƒn function, chÃºng rÃµ rÃ ng lÃ  quan trá»ng: nhÃ¬n vÃ o chÃºng, chÃºng to!</blockquote>
    HÃ¬nh nÃ y Ä‘Æ°á»£c láº¥y tá»« bÃ i <a href="https://htmx.org/essays/codin-dirty/" target="_blank">Codin' Dirty</a> cá»§a Carson Gross. Báº¡n sáº½ tÃ¬m tháº¥y <a href="https://htmx.org/essays/codin-dirty/#real-world-examples" target="_blank">vÃ­ dá»¥ thá»±c táº¿</a> vá» deep function á»Ÿ Ä‘Ã³.
</details>

P.S. Náº¿u báº¡n nghÄ© chÃºng ta Ä‘ang á»§ng há»™ God object phÃ¬nh to vá»›i quÃ¡ nhiá»u responsibility, báº¡n hiá»ƒu sai rá»“i.

## Responsible cho má»™t thing
QuÃ¡ thÆ°á»ng xuyÃªn, chÃºng ta táº¡o ra nhiá»u shallow module, theo má»™t nguyÃªn táº¯c mÆ¡ há»“ "má»™t module nÃªn responsible cho má»™t, vÃ  chá»‰ má»™t, thing". CÃ¡i "má»™t thing" mÆ¡ há»“ nÃ y lÃ  gÃ¬? Khá»Ÿi táº¡o má»™t object lÃ  má»™t thing, Ä‘Ãºng khÃ´ng? Váº­y [MetricsProviderFactoryFactory](https://minds.md/benji/frameworks) cÃ³ váº» á»•n. **TÃªn vÃ  interface cá»§a cÃ¡c class nhÆ° váº­y cÃ³ xu hÆ°á»›ng tá»‘n nÃ£o hÆ¡n toÃ n bá»™ implementation cá»§a chÃºng, Ä‘Ã³ lÃ  abstraction kiá»ƒu gÃ¬?** CÃ³ gÃ¬ Ä‘Ã³ sai sai.

ChÃºng ta thay Ä‘á»•i há»‡ thá»‘ng Ä‘á»ƒ thá»a mÃ£n user vÃ  stakeholder. ChÃºng ta responsible vá»›i há».

> Má»™t module nÃªn responsible vá»›i má»™t, vÃ  chá»‰ má»™t, user hoáº·c stakeholder.

ÄÃ¢y lÃ  báº£n cháº¥t cá»§a Single Responsibility Principle. NÃ³i Ä‘Æ¡n giáº£n, náº¿u ta gÃ¢y ra bug á»Ÿ má»™t chá»—, rá»“i hai business people khÃ¡c nhau Ä‘áº¿n phÃ n nÃ n, ta Ä‘Ã£ vi pháº¡m nguyÃªn táº¯c. NÃ³ khÃ´ng liÃªn quan gÃ¬ Ä‘áº¿n sá»‘ lÆ°á»£ng thing ta lÃ m trong module.

NhÆ°ng ngay cáº£ bÃ¢y giá», rule nÃ y cÃ³ thá»ƒ gÃ¢y háº¡i nhiá»u hÆ¡n lá»£i. NguyÃªn táº¯c nÃ y cÃ³ thá»ƒ Ä‘Æ°á»£c hiá»ƒu theo nhiá»u cÃ¡ch khÃ¡c nhau tÃ¹y má»—i ngÆ°á»i. Approach tá»‘t hÆ¡n lÃ  nhÃ¬n vÃ o lÆ°á»£ng cognitive load mÃ  nÃ³ táº¡o ra. Ráº¥t tá»‘n nÃ£o Ä‘á»ƒ nhá»› ráº±ng thay Ä‘á»•i á»Ÿ má»™t chá»— cÃ³ thá»ƒ trigger chuá»—i pháº£n á»©ng qua cÃ¡c business stream khÃ¡c nhau. VÃ  chá»‰ váº­y thÃ´i, khÃ´ng cáº§n há»c fancy term gÃ¬ cáº£.

## QuÃ¡ nhiá»u shallow microservice
NguyÃªn táº¯c shallow-deep module nÃ y scale-agnostic, vÃ  ta cÃ³ thá»ƒ Ã¡p dá»¥ng nÃ³ cho microservices architecture. QuÃ¡ nhiá»u shallow microservice khÃ´ng tá»‘t - ngÃ nh Ä‘ang hÆ°á»›ng tá»›i "macroservice", tá»©c lÃ  service khÃ´ng quÃ¡ shallow (=deep). Má»™t trong nhá»¯ng hiá»‡n tÆ°á»£ng tá»‡ nháº¥t vÃ  khÃ³ fix nháº¥t lÃ  distributed monolith, thÆ°á»ng lÃ  káº¿t quáº£ cá»§a viá»‡c phÃ¢n tÃ¡ch shallow quÃ¡ má»©c nÃ y.

TÃ´i tá»«ng tÆ° váº¥n cho má»™t startup nÆ¡i team nÄƒm developer táº¡o ra 17(!) microservice. Há» cháº­m 10 thÃ¡ng so vá»›i lá»‹ch trÃ¬nh vÃ  khÃ´ng gáº§n tá»›i public release. Má»—i requirement má»›i dáº«n Ä‘áº¿n thay Ä‘á»•i trong 4+ microservice. Máº¥t vÃ´ cÃ¹ng nhiá»u thá»i gian Ä‘á»ƒ reproduce vÃ  debug issue trong distributed system nhÆ° váº­y. Cáº£ time to market vÃ  cognitive load Ä‘á»u cao khÃ´ng thá»ƒ cháº¥p nháº­n. `ğŸ¤¯`

ÄÃ¢y cÃ³ pháº£i cÃ¡ch Ä‘Ãºng Ä‘á»ƒ tiáº¿p cáº­n uncertainty cá»§a há»‡ thá»‘ng má»›i? Cá»±c ká»³ khÃ³ Ä‘á»ƒ xÃ¡c Ä‘á»‹nh Ä‘Ãºng logical boundary ngay tá»« Ä‘áº§u. Äiá»u quan trá»ng lÃ  Ä‘Æ°a ra quyáº¿t Ä‘á»‹nh cÃ ng muá»™n cÃ ng tá»‘t, vÃ¬ lÃºc Ä‘Ã³ báº¡n cÃ³ nhiá»u thÃ´ng tin nháº¥t. Báº±ng cÃ¡ch Ä‘Æ°a network layer vÃ o ngay tá»« Ä‘áº§u, ta lÃ m cho design decision khÃ³ revert ngay tá»« lÃºc báº¯t Ä‘áº§u. LÃ½ do duy nháº¥t cá»§a team lÃ : "CÃ¡c cÃ´ng ty FAANG Ä‘Ã£ chá»©ng minh microservices architecture hiá»‡u quáº£". *Hello, báº¡n pháº£i thÃ´i mÆ¡ lá»›n Ä‘i.*

[Tranh luáº­n Tanenbaum-Torvalds](https://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate) cho ráº±ng thiáº¿t káº¿ monolithic cá»§a Linux lÃ  lá»—i thá»i vÃ  nÃªn dÃ¹ng microkernel architecture thay tháº¿. Tháº­t váº­y, thiáº¿t káº¿ microkernel cÃ³ váº» vÆ°á»£t trá»™i "tá»« gÃ³c Ä‘á»™ lÃ½ thuyáº¿t vÃ  tháº©m má»¹". Vá» máº·t thá»±c táº¿ - ba tháº­p ká»· sau, GNU Hurd dá»±a trÃªn microkernel váº«n Ä‘ang phÃ¡t triá»ƒn, cÃ²n monolithic Linux thÃ¬ á»Ÿ kháº¯p nÆ¡i. Trang nÃ y cháº¡y báº±ng Linux, áº¥m Ä‘un nÆ°á»›c thÃ´ng minh cá»§a báº¡n cÅ©ng cháº¡y Linux. Báº±ng monolithic Linux.

Má»™t monolith Ä‘Æ°á»£c craft tá»‘t vá»›i cÃ¡c module tháº­t sá»± isolated thÆ°á»ng linh hoáº¡t hÆ¡n nhiá»u so vá»›i má»™t Ä‘á»‘ng microservice. NÃ³ cÅ©ng cáº§n Ã­t cognitive effort hÆ¡n nhiá»u Ä‘á»ƒ maintain. Chá»‰ khi nhu cáº§u deploy riÃªng biá»‡t trá»Ÿ nÃªn quan trá»ng, nhÆ° scale development team, báº¡n má»›i nÃªn xem xÃ©t thÃªm network layer giá»¯a cÃ¡c module, cÃ¡c microservice tÆ°Æ¡ng lai.

## NgÃ´n ngá»¯ feature-rich
ChÃºng ta hÃ o há»©ng khi cÃ¡c feature má»›i Ä‘Æ°á»£c release trong ngÃ´n ngá»¯ yÃªu thÃ­ch. ChÃºng ta dÃ nh thá»i gian há»c cÃ¡c feature nÃ y, build code dá»±a trÃªn chÃºng.

Náº¿u cÃ³ nhiá»u feature, ta cÃ³ thá»ƒ tá»‘n ná»­a giá» chÆ¡i vá»›i vÃ i dÃ²ng code, Ä‘á»ƒ dÃ¹ng feature nÃ y hay feature kia. VÃ  Ä‘Ã³ hÆ¡i lÃ£ng phÃ­ thá»i gian. NhÆ°ng tá»‡ hÆ¡n, **khi báº¡n quay láº¡i sau, báº¡n pháº£i recreate láº¡i thought process Ä‘Ã³!**

**Báº¡n khÃ´ng chá»‰ pháº£i hiá»ƒu chÆ°Æ¡ng trÃ¬nh phá»©c táº¡p nÃ y, báº¡n cÃ²n pháº£i hiá»ƒu táº¡i sao má»™t programmer quyáº¿t Ä‘á»‹nh Ä‘Ã¢y lÃ  cÃ¡ch tiáº¿p cáº­n váº¥n Ä‘á» tá»« cÃ¡c feature cÃ³ sáºµn.** `ğŸ¤¯`

Nhá»¯ng phÃ¡t biá»ƒu nÃ y Ä‘Æ°á»£c Ä‘Æ°a ra bá»Ÿi khÃ´ng ai khÃ¡c ngoÃ i Rob Pike.

> Giáº£m cognitive load báº±ng cÃ¡ch giá»›i háº¡n sá»‘ lÆ°á»£ng choice.

Language feature lÃ  OK, miá»…n lÃ  chÃºng orthogonal vá»›i nhau.

<details>
  <summary><b>Suy nghÄ© tá»« má»™t engineer vá»›i 20 nÄƒm kinh nghiá»‡m C++ â­ï¸</b></summary>
  <br>
  HÃ´m trÆ°á»›c tÃ´i nhÃ¬n RSS reader vÃ  nháº­n ra cÃ³ khoáº£ng ba trÄƒm bÃ i chÆ°a Ä‘á»c dÆ°á»›i tag "C++". TÃ´i chÆ°a Ä‘á»c má»™t bÃ i nÃ o vá» ngÃ´n ngá»¯ nÃ y tá»« mÃ¹a hÃ¨ nÄƒm ngoÃ¡i, vÃ  tÃ´i cáº£m tháº¥y tuyá»‡t!<br><br>
  TÃ´i Ä‘Ã£ dÃ¹ng C++ Ä‘Æ°á»£c 20 nÄƒm rá»“i, gáº§n hai pháº§n ba cuá»™c Ä‘á»i tÃ´i. Pháº§n lá»›n kinh nghiá»‡m cá»§a tÃ´i lÃ  deal vá»›i nhá»¯ng gÃ³c tá»‘i nháº¥t cá»§a ngÃ´n ngá»¯ (nhÆ° undefined behaviour Ä‘á»§ loáº¡i). ÄÃ¢y khÃ´ng pháº£i kinh nghiá»‡m tÃ¡i sá»­ dá»¥ng Ä‘Æ°á»£c, vÃ  hÆ¡i Ä‘Ã¡ng sá»£ khi pháº£i bá» háº¿t bÃ¢y giá».<br><br>
  Kiá»ƒu nhÆ°, báº¡n cÃ³ thá»ƒ tÆ°á»Ÿng tÆ°á»£ng Ä‘Æ°á»£c khÃ´ng, token <code>||</code> cÃ³ nghÄ©a khÃ¡c nhau trong <code>requires ((!P&lt;T&gt; || !Q&lt;T&gt;))</code> vÃ  trong <code>requires (!(P&lt;T&gt; || Q&lt;T&gt;))</code>. CÃ¡i Ä‘áº§u lÃ  constraint disjunction, cÃ¡i thá»© hai lÃ  operator logical OR quen thuá»™c, vÃ  chÃºng hoáº¡t Ä‘á»™ng khÃ¡c nhau.<br><br>
  Báº¡n khÃ´ng thá»ƒ allocate space cho trivial type vÃ  chá»‰ <code>memcpy</code> má»™t set byte vÃ o Ä‘Ã³ mÃ  khÃ´ng cáº§n thÃªm effort - Ä‘iá»u Ä‘Ã³ sáº½ khÃ´ng báº¯t Ä‘áº§u lifetime cá»§a má»™t object. ÄÃ¢y lÃ  tÃ¬nh huá»‘ng trÆ°á»›c C++20. NÃ³ Ä‘Ã£ Ä‘Æ°á»£c fix trong C++20, nhÆ°ng cognitive load cá»§a ngÃ´n ngá»¯ chá»‰ tÄƒng lÃªn.<br><br>
  Cognitive load liÃªn tá»¥c tÄƒng, dÃ¹ má»i thá»© Ä‘Æ°á»£c fix. TÃ´i pháº£i biáº¿t cÃ¡i gÃ¬ Ä‘Æ°á»£c fix, khi nÃ o nÃ³ Ä‘Æ°á»£c fix, vÃ  trÆ°á»›c Ä‘Ã³ nÃ³ nhÆ° tháº¿ nÃ o. TÃ´i lÃ  má»™t professional mÃ . Cháº¯c cháº¯n, C++ giá»i vá» legacy support, Ä‘iá»u Ä‘Ã³ cÅ©ng cÃ³ nghÄ©a lÃ  báº¡n <b>sáº½ gáº·p</b> legacy Ä‘Ã³. VÃ­ dá»¥, thÃ¡ng trÆ°á»›c má»™t Ä‘á»“ng nghiá»‡p há»i tÃ´i vá» má»™t behaviour trong C++03. <code>ğŸ¤¯</code><br><br>
  CÃ³ 20 cÃ¡ch initialization. Uniform initialization syntax Ä‘Æ°á»£c thÃªm vÃ o. BÃ¢y giá» cÃ³ 21 cÃ¡ch initialization. NhÃ¢n tiá»‡n, cÃ³ ai nhá»› rule Ä‘á»ƒ chá»n constructor tá»« initializer list khÃ´ng? Má»™t cÃ¡i gÃ¬ Ä‘Ã³ vá» implicit conversion vá»›i Ã­t loss thÃ´ng tin nháº¥t, <i>nhÆ°ng náº¿u</i> giÃ¡ trá»‹ Ä‘Æ°á»£c biáº¿t statically thÃ¬... <code>ğŸ¤¯</code><br><br>
  <b>Cognitive load tÄƒng lÃªn nÃ y khÃ´ng pháº£i do business task Ä‘ang lÃ m. KhÃ´ng pháº£i intrinsic complexity cá»§a domain. NÃ³ chá»‰ á»Ÿ Ä‘Ã³ do lÃ½ do lá»‹ch sá»­</b> (<i>extraneous cognitive load</i>).<br><br>
  TÃ´i pháº£i nghÄ© ra vÃ i rule. Kiá»ƒu nhÆ°, náº¿u dÃ²ng code Ä‘Ã³ khÃ´ng rÃµ rÃ ng vÃ  tÃ´i pháº£i nhá»› standard, tá»‘t hÆ¡n lÃ  khÃ´ng viáº¿t kiá»ƒu Ä‘Ã³. Standard dÃ i khoáº£ng 1500 trang, nhÃ¢n tiá»‡n.<br><br>
  <b>TÃ´i hoÃ n toÃ n khÃ´ng blame C++.</b> TÃ´i yÃªu ngÃ´n ngá»¯ nÃ y. Chá»‰ lÃ  tÃ´i má»‡t rá»“i.<br><br>
  <p>Cáº£m Æ¡n <a href="https://0xd34df00d.me" target="_blank">0xd34df00d</a> Ä‘Ã£ viáº¿t.</p>
</details>

## Business logic vÃ  HTTP status code
á» backend ta return:
`401` cho expired JWT token
`403` cho khÃ´ng Ä‘á»§ access
`418` cho banned user

CÃ¡c engineer á»Ÿ frontend dÃ¹ng backend API Ä‘á»ƒ implement login functionality. Há» sáº½ pháº£i táº¡m thá»i táº¡o cognitive load sau trong Ä‘áº§u:
`401` lÃ  cho expired JWT token // `ğŸ§ +`, ok chá»‰ nhá»› táº¡m thá»i
`403` lÃ  cho khÃ´ng Ä‘á»§ access // `ğŸ§ ++`
`418` lÃ  cho banned user // `ğŸ§ +++`

Frontend developer sáº½ (hy vá»ng) táº¡o má»™t loáº¡i dictionary `numeric status -> meaning` á»Ÿ phÃ­a há», Ä‘á»ƒ cÃ¡c contributor tháº¿ há»‡ sau khÃ´ng pháº£i recreate mapping nÃ y trong Ä‘áº§u.

Rá»“i QA engineer vÃ o cuá»™c:
"Hey, tÃ´i nháº­n Ä‘Æ°á»£c status `403`, Ä‘Ã³ lÃ  expired token hay khÃ´ng Ä‘á»§ access?"
**QA engineer khÃ´ng thá»ƒ nháº£y tháº³ng vÃ o testing, vÃ¬ trÆ°á»›c tiÃªn há» pháº£i recreate cognitive load mÃ  engineer backend Ä‘Ã£ táº¡o.**

Táº¡i sao pháº£i giá»¯ custom mapping nÃ y trong working memory? Tá»‘t hÆ¡n lÃ  abstract business detail ra khá»i HTTP transfer protocol, vÃ  return code tá»± mÃ´ táº£ trá»±c tiáº¿p trong response body:
```json
{
    "code": "jwt_has_expired"
}
```

Cognitive load á»Ÿ phÃ­a frontend: `ğŸ§ ` (fresh, khÃ´ng cÃ³ fact nÃ o Ä‘Æ°á»£c giá»¯ trong Ä‘áº§u)
Cognitive load á»Ÿ phÃ­a QA: `ğŸ§ `

Rule tÆ°Æ¡ng tá»± Ã¡p dá»¥ng cho táº¥t cáº£ loáº¡i numeric status (trong database hay báº¥t ká»³ Ä‘Ã¢u) - **Æ°u tiÃªn string tá»± mÃ´ táº£.** ChÃºng ta khÃ´ng cÃ²n á»Ÿ thá»i Ä‘áº¡i mÃ¡y 640K Ä‘á»ƒ optimize memory ná»¯a.

> Má»i ngÆ°á»i dÃ nh thá»i gian tranh luáº­n giá»¯a `401` vÃ  `403`, Ä‘Æ°a ra quyáº¿t Ä‘á»‹nh dá»±a trÃªn mental model riÃªng cá»§a há». Developer má»›i vÃ o pháº£i recreate thought process Ä‘Ã³. Báº¡n cÃ³ thá»ƒ Ä‘Ã£ document "why" (ADR) cho code, giÃºp newcomer hiá»ƒu quyáº¿t Ä‘á»‹nh Ä‘Ã£ Ä‘Æ°a ra. NhÆ°ng cuá»‘i cÃ¹ng nÃ³ cháº³ng cÃ³ Ã½ nghÄ©a gÃ¬. Ta cÃ³ thá»ƒ tÃ¡ch error thÃ nh user-related hoáº·c server-related, nhÆ°ng ngoÃ i ra thÃ¬ má»i thá»© hÆ¡i mÆ¡ há»“.

P.S. ThÆ°á»ng ráº¥t tá»‘n nÃ£o Ä‘á»ƒ phÃ¢n biá»‡t giá»¯a "authentication" vÃ  "authorization". Ta cÃ³ thá»ƒ dÃ¹ng term Ä‘Æ¡n giáº£n hÆ¡n nhÆ° ["login" vÃ  "permission"](https://ntietz.com/blog/lets-say-instead-of-auth/) Ä‘á»ƒ giáº£m cognitive load.

## Láº¡m dá»¥ng nguyÃªn táº¯c DRY

Do not repeat yourself - Ä‘Ã³ lÃ  má»™t trong nhá»¯ng nguyÃªn táº¯c Ä‘áº§u tiÃªn báº¡n Ä‘Æ°á»£c dáº¡y khi lÃ  software engineer. NÃ³ Ä‘Æ°á»£c nhÃºng sÃ¢u vÃ o báº£n thÃ¢n chÃºng ta Ä‘áº¿n ná»—i ta khÃ´ng thá»ƒ chá»‹u Ä‘Æ°á»£c viá»‡c cÃ³ thÃªm vÃ i dÃ²ng code. Máº·c dÃ¹ nhÃ¬n chung lÃ  má»™t rule tá»‘t vÃ  fundamental, khi overuse nÃ³ dáº«n Ä‘áº¿n cognitive load mÃ  ta khÃ´ng thá»ƒ handle.

NgÃ y nay, má»i ngÆ°á»i build software dá»±a trÃªn cÃ¡c component tÃ¡ch biá»‡t vá» máº·t logic. ThÆ°á»ng chÃºng Ä‘Æ°á»£c phÃ¢n phá»‘i giá»¯a nhiá»u codebase Ä‘áº¡i diá»‡n cho cÃ¡c service riÃªng. Khi báº¡n cá»‘ gáº¯ng loáº¡i bá» má»i repetition, báº¡n cÃ³ thá»ƒ táº¡o ra tight coupling giá»¯a cÃ¡c component khÃ´ng liÃªn quan. Káº¿t quáº£ lÃ , thay Ä‘á»•i á»Ÿ má»™t pháº§n cÃ³ thá»ƒ cÃ³ háº­u quáº£ ngoÃ i Ã½ muá»‘n á»Ÿ cÃ¡c khu vá»±c khÃ¡c cÃ³ váº» khÃ´ng liÃªn quan. NÃ³ cÅ©ng cÃ³ thá»ƒ cáº£n trá»Ÿ kháº£ nÄƒng replace hoáº·c modify tá»«ng component mÃ  khÃ´ng áº£nh hÆ°á»Ÿng toÃ n bá»™ há»‡ thá»‘ng. `ğŸ¤¯`

Thá»±c táº¿, váº¥n Ä‘á» tÆ°Æ¡ng tá»± náº£y sinh ngay cáº£ trong má»™t module Ä‘Æ¡n láº». Báº¡n cÃ³ thá»ƒ extract common functionality quÃ¡ sá»›m, dá»±a trÃªn sá»± giá»‘ng nhau cÃ³ thá»ƒ khÃ´ng thá»±c sá»± tá»“n táº¡i vá» lÃ¢u dÃ i. Äiá»u nÃ y cÃ³ thá»ƒ dáº«n Ä‘áº¿n cÃ¡c abstraction khÃ´ng cáº§n thiáº¿t khÃ³ modify hoáº·c extend.

Rob Pike tá»«ng nÃ³i:

> A little copying is better than a little dependency.

ChÃºng ta bá»‹ cÃ¡m dá»— Ä‘á»ƒ khÃ´ng reinvent bÃ¡nh xe máº¡nh Ä‘áº¿n ná»—i sáºµn sÃ ng import cÃ¡c library to náº·ng Ä‘á»ƒ dÃ¹ng má»™t function nhá» mÃ  ta dá»… dÃ ng viáº¿t Ä‘Æ°á»£c.

**Táº¥t cáº£ dependency cá»§a báº¡n lÃ  code cá»§a báº¡n.** Äi qua 10+ level cá»§a stack trace cá»§a library Ä‘Ã£ import vÃ  tÃ¬m ra chá»— sai (*vÃ¬ má»i thá»© Ä‘á»u sai*) ráº¥t Ä‘au Ä‘á»›n.

## Tight coupling vá»›i framework
CÃ³ ráº¥t nhiá»u "magic" trong framework. Báº±ng cÃ¡ch dá»±a quÃ¡ nhiá»u vÃ o framework, **ta buá»™c táº¥t cáº£ developer sau nÃ y pháº£i há»c "magic" Ä‘Ã³ trÆ°á»›c.** CÃ³ thá»ƒ máº¥t hÃ ng thÃ¡ng. Máº·c dÃ¹ framework cho phÃ©p ta launch MVP trong vÃ i ngÃ y, vá» lÃ¢u dÃ i chÃºng cÃ³ xu hÆ°á»›ng thÃªm complexity vÃ  cognitive load khÃ´ng cáº§n thiáº¿t.

Tá»‡ hÆ¡n, táº¡i má»™t thá»i Ä‘iá»ƒm nÃ o Ä‘Ã³ framework cÃ³ thá»ƒ trá»Ÿ thÃ nh constraint Ä‘Ã¡ng ká»ƒ khi Ä‘á»‘i máº·t vá»›i requirement má»›i khÃ´ng fit architecture. Tá»« Ä‘Ã¢y má»i ngÆ°á»i fork framework vÃ  maintain custom version cá»§a riÃªng há». TÆ°á»Ÿng tÆ°á»£ng lÆ°á»£ng cognitive load mÃ  má»™t newcomer pháº£i build (tá»©c lÃ  há»c custom framework nÃ y) Ä‘á»ƒ deliver báº¥t ká»³ value nÃ o. `ğŸ¤¯`

**ChÃºng ta hoÃ n toÃ n khÃ´ng advocate viá»‡c invent má»i thá»© from scratch!**

Ta cÃ³ thá»ƒ viáº¿t code theo cÃ¡ch hÆ¡i framework-agnostic. Business logic khÃ´ng nÃªn náº±m trong framework; thay vÃ o Ä‘Ã³, nÃ³ nÃªn dÃ¹ng cÃ¡c component cá»§a framework. Äáº·t framework ra ngoÃ i core logic cá»§a báº¡n. DÃ¹ng framework theo kiá»ƒu library. Äiá»u nÃ y cho phÃ©p contributor má»›i add value tá»« ngÃ y Ä‘áº§u tiÃªn, khÃ´ng cáº§n pháº£i Ä‘i qua debris cá»§a framework-related complexity trÆ°á»›c.

> [Why I Hate Frameworks](https://minds.md/benji/frameworks)

## Layered architecture
CÃ³ má»™t sá»± hÃ o há»©ng vá» engineering Ä‘á»‘i vá»›i táº¥t cáº£ thá»© nÃ y.

Báº£n thÃ¢n tÃ´i tá»«ng lÃ  ngÆ°á»i á»§ng há»™ nhiá»‡t thÃ nh Hexagonal/Onion Architecture trong nhiá»u nÄƒm. TÃ´i dÃ¹ng nÃ³ á»Ÿ Ä‘Ã¢y vÃ  kia vÃ  khuyáº¿n khÃ­ch cÃ¡c team khÃ¡c lÃ m nhÆ° váº­y. Äá»™ phá»©c táº¡p cá»§a project tÄƒng lÃªn, sá»‘ lÆ°á»£ng file tÄƒng gáº¥p Ä‘Ã´i. Cáº£m giÃ¡c nhÆ° ta Ä‘ang viáº¿t ráº¥t nhiá»u glue code. Vá»›i requirement thay Ä‘á»•i liÃªn tá»¥c, ta pháº£i thay Ä‘á»•i qua nhiá»u layer cá»§a abstraction, táº¥t cáº£ trá»Ÿ nÃªn táº» nháº¡t. `ğŸ¤¯`

**Abstraction Ä‘Æ°á»£c cho lÃ  áº©n complexity, á»Ÿ Ä‘Ã¢y nÃ³ chá»‰ thÃªm [indirection](https://fhur.me/posts/2024/thats-not-an-abstraction).** Nháº£y tá»« call nÃ y sang call khÃ¡c Ä‘á»ƒ Ä‘á»c theo vÃ  tÃ¬m ra chá»— sai vÃ  thiáº¿u cÃ¡i gÃ¬ lÃ  requirement quan trá»ng Ä‘á»ƒ nhanh chÃ³ng giáº£i quyáº¿t váº¥n Ä‘á». Vá»›i viá»‡c layer uncoupling cá»§a architecture nÃ y, nÃ³ cáº§n má»™t factor exponential cá»§a cÃ¡c trace thÃªm, thÆ°á»ng khÃ´ng liÃªn tá»¥c, Ä‘á»ƒ Ä‘áº¿n Ä‘iá»ƒm xáº£y ra lá»—i. Má»—i trace nhÆ° váº­y chiáº¿m chá»— trong limited working memory cá»§a ta. `ğŸ¤¯`

<div align="center">
  <img src="/img/layers.png" alt="Layers" width="400">
</div>

Architecture nÃ y lÃ  thá»© cÃ³ váº» há»£p lÃ½ ban Ä‘áº§u, nhÆ°ng má»—i láº§n ta thá»­ Ã¡p dá»¥ng vÃ o project thÃ¬ nÃ³ gÃ¢y háº¡i nhiá»u hÆ¡n lá»£i. ChÃºng ta dÃ nh nhiá»u nÄƒm cho hoáº¡t Ä‘á»™ng tinh tháº§n khÃ´ng cáº§n thiáº¿t vÃ  viáº¿t glue code vÃ´ dá»¥ng khÃ´ng cÃ³ business value rÃµ rÃ ng. NgÆ°á»£c láº¡i, ta lÃ m má»i thá»© tá»‡ hÆ¡n cho business báº±ng cÃ¡ch buá»™c newcomer pháº£i há»c approach (mental model) cá»§a ta trÆ°á»›c. Time to market xáº¥u Ä‘i. Cuá»‘i cÃ¹ng, ta tá»« bá» táº¥t cáº£ Ä‘á»ƒ á»§ng há»™ dependency inversion principle cÅ© ká»¹ tá»‘t Ä‘áº¹p. **KhÃ´ng cÃ³ port/adapter term Ä‘á»ƒ há»c, khÃ´ng cÃ³ layer horizontal abstraction khÃ´ng cáº§n thiáº¿t, khÃ´ng cÃ³ extraneous cognitive load.**

Náº¿u báº¡n nghÄ© ráº±ng layering nhÆ° váº­y sáº½ cho phÃ©p báº¡n nhanh chÃ³ng replace database hoáº·c dependency khÃ¡c, báº¡n nháº§m rá»“i. Thay Ä‘á»•i storage gÃ¢y ra nhiá»u váº¥n Ä‘á», vÃ  tin tÃ´i Ä‘i, cÃ³ má»™t vÃ i abstraction cho data access layer lÃ  Ã­t lo láº¯ng nháº¥t cá»§a báº¡n. Tá»‘t nháº¥t, abstraction cÃ³ thá»ƒ tiáº¿t kiá»‡m khoáº£ng 10% thá»i gian migration (náº¿u cÃ³), pain thá»±c sá»± náº±m á»Ÿ data model incompatibility, communication protocol, distributed system challenge, vÃ  [implicit interface](https://www.hyrumslaw.com).

> Vá»›i Ä‘á»§ sá»‘ lÆ°á»£ng user cá»§a má»™t API,
> khÃ´ng quan trá»ng báº¡n promise gÃ¬ trong contract:
> táº¥t cáº£ observable behaviour cá»§a há»‡ thá»‘ng
> sáº½ Ä‘Æ°á»£c ai Ä‘Ã³ depend vÃ o.

ChÃºng tÃ´i Ä‘Ã£ lÃ m storage migration, vÃ  máº¥t khoáº£ng 10 thÃ¡ng. Há»‡ thá»‘ng cÅ© lÃ  single-threaded, nÃªn cÃ¡c event exposed lÃ  sequential. Táº¥t cáº£ há»‡ thá»‘ng cá»§a chÃºng tÃ´i depend vÃ o observed behaviour Ä‘Ã³. Behaviour nÃ y khÃ´ng pháº£i part cá»§a API contract, khÃ´ng Ä‘Æ°á»£c pháº£n Ã¡nh trong code. Storage má»›i distributed khÃ´ng cÃ³ guarantee Ä‘Ã³ - cÃ¡c event ra ngoÃ i out-of-order. ChÃºng tÃ´i chá»‰ máº¥t vÃ i giá» code storage adapter má»›i, nhá» abstraction. **ChÃºng tÃ´i dÃ nh 10 thÃ¡ng tiáº¿p theo Ä‘á»ƒ deal vá»›i out-of-order event vÃ  cÃ¡c challenge khÃ¡c.** Giá» tháº­t buá»“n cÆ°á»i khi nÃ³i abstraction giÃºp ta replace component nhanh chÃ³ng.

**Váº­y, táº¡i sao pháº£i tráº£ giÃ¡ cá»§a cognitive load cao cho layered architecture nhÆ° váº­y, náº¿u nÃ³ khÃ´ng pay off trong tÆ°Æ¡ng lai?** HÆ¡n ná»¯a, trong háº§u háº¿t trÆ°á»ng há»£p, tÆ°Æ¡ng lai thay tháº¿ core component Ä‘Ã³ khÃ´ng bao giá» xáº£y ra.

CÃ¡c architecture nÃ y khÃ´ng fundamental, chÃºng chá»‰ lÃ  háº­u quáº£ chá»§ quan, biased cá»§a cÃ¡c nguyÃªn táº¯c fundamental hÆ¡n. Táº¡i sao rely vÃ o nhá»¯ng interpretation chá»§ quan Ä‘Ã³? Follow cÃ¡c rule fundamental thay tháº¿: dependency inversion principle, single source of truth, cognitive load vÃ  information hiding. Business logic khÃ´ng nÃªn depend vÃ o low-level module nhÆ° database, UI hay framework. Ta nÃªn cÃ³ thá»ƒ viáº¿t test cho core logic mÃ  khÃ´ng lo vá» infrastructure, vÃ  chá»‰ váº­y thÃ´i. [Tháº£o luáº­n](https://github.com/zakirullin/cognitive-load/discussions/24).

Äá»«ng thÃªm layer abstraction vÃ¬ architecture. ThÃªm chÃºng khi báº¡n cáº§n extension point Ä‘Æ°á»£c justify bá»Ÿi lÃ½ do thá»±c táº¿.

**[Layer abstraction khÃ´ng free](https://blog.jooq.org/why-you-should-not-implement-layered-architecture), chÃºng pháº£i Ä‘Æ°á»£c giá»¯ trong limited working memory cá»§a ta.**

## Domain-driven design
Domain-driven design cÃ³ má»™t vÃ i Ä‘iá»ƒm tá»‘t, máº·c dÃ¹ nÃ³ thÆ°á»ng bá»‹ hiá»ƒu sai. Má»i ngÆ°á»i nÃ³i, "ChÃºng ta viáº¿t code trong DDD", hÆ¡i láº¡, vÃ¬ DDD nhiá»u vá» problem space hÆ¡n lÃ  solution space.

Ubiquitous language, domain, bounded context, aggregate, event storming Ä‘á»u vá» problem space. ChÃºng Ä‘Æ°á»£c dÃ¹ng Ä‘á»ƒ giÃºp ta há»c insight vá» domain vÃ  extract boundary. DDD cho phÃ©p developer, domain expert vÃ  business people giao tiáº¿p hiá»‡u quáº£ báº±ng má»™t ngÃ´n ngá»¯ Ä‘Æ¡n nháº¥t, thá»‘ng nháº¥t. Thay vÃ¬ focus vÃ o cÃ¡c problem space aspect cá»§a DDD nÃ y, ta cÃ³ xu hÆ°á»›ng nháº¥n máº¡nh folder structure cá»¥ thá»ƒ, service, repository, vÃ  cÃ¡c solution space technique khÃ¡c.

Ráº¥t cÃ³ thá»ƒ cÃ¡ch ta interpret DDD lÃ  duy nháº¥t vÃ  chá»§ quan. VÃ  náº¿u ta build code dá»±a trÃªn sá»± hiá»ƒu biáº¿t nÃ y, tá»©c lÃ  náº¿u ta táº¡o ra nhiá»u extraneous cognitive load - cÃ¡c developer tÆ°Æ¡ng lai sáº½ khá»‘n khá»•. `ğŸ¤¯`

Team Topologies cung cáº¥p framework tá»‘t hÆ¡n nhiá»u, dá»… hiá»ƒu hÆ¡n giÃºp ta split cognitive load giá»¯a cÃ¡c team. Engineer cÃ³ xu hÆ°á»›ng phÃ¡t triá»ƒn mental model hÆ¡i giá»‘ng nhau sau khi há»c vá» Team Topologies. DDD, máº·t khÃ¡c, dÆ°á»ng nhÆ° táº¡o ra 10 mental model khÃ¡c nhau cho 10 ngÆ°á»i Ä‘á»c khÃ¡c nhau. Thay vÃ¬ lÃ  common ground, nÃ³ trá»Ÿ thÃ nh battleground cho cÃ¡c cuá»™c tranh luáº­n khÃ´ng cáº§n thiáº¿t.

## Cognitive load trong familiar project

> Váº¥n Ä‘á» lÃ  **familiarity khÃ´ng giá»‘ng simplicity.** ChÃºng *cáº£m tháº¥y* giá»‘ng nhau â€” cÃ¹ng sá»± dá»… dÃ ng di chuyá»ƒn qua má»™t khÃ´ng gian mÃ  khÃ´ng cáº§n nhiá»u mental effort â€” nhÆ°ng vÃ¬ nhá»¯ng lÃ½ do ráº¥t khÃ¡c nhau. Má»—i trick "clever" (Ä‘á»c: "tá»± chiá»u chuá»™ng") vÃ  non-idiomatic mÃ  báº¡n dÃ¹ng táº¡o ra learning penalty cho má»i ngÆ°á»i khÃ¡c. Má»™t khi há» Ä‘Ã£ há»c xong, há» sáº½ tháº¥y lÃ m viá»‡c vá»›i code Ã­t khÃ³ khÄƒn hÆ¡n. VÃ¬ váº­y khÃ³ Ä‘á»ƒ nháº­n ra cÃ¡ch simplify code mÃ  báº¡n Ä‘Ã£ quen thuá»™c. ÄÃ¢y lÃ  lÃ½ do tÃ´i cá»‘ gáº¯ng Ä‘á»ƒ "the new kid" critique code trÆ°á»›c khi há» bá»‹ institutionalized quÃ¡ nhiá»u!
>
> Ráº¥t cÃ³ thá»ƒ tÃ¡c giáº£ trÆ°á»›c Ä‘Ã£ táº¡o ra mess khá»•ng lá»“ nÃ y tá»«ng increment nhá», khÃ´ng pháº£i má»™t láº§n. VÃ¬ váº­y báº¡n lÃ  ngÆ°á»i Ä‘áº§u tiÃªn pháº£i cá»‘ gáº¯ng hiá»ƒu táº¥t cáº£ cÃ¹ng má»™t lÃºc.
>
> Trong class cá»§a tÃ´i, tÃ´i mÃ´ táº£ má»™t SQL stored procedure sprawling mÃ  chÃºng ta xem má»™t ngÃ y, vá»›i hÃ ng trÄƒm dÃ²ng conditional trong WHERE clause khá»•ng lá»“. Ai Ä‘Ã³ há»i lÃ m sao ai cÃ³ thá»ƒ Ä‘á»ƒ nÃ³ tá»‡ Ä‘áº¿n váº­y. TÃ´i nÃ³i vá»›i há»: "Khi chá»‰ cÃ³ 2 hoáº·c 3 conditional, thÃªm má»™t cÃ¡i ná»¯a khÃ´ng táº¡o ra khÃ¡c biá»‡t gÃ¬. Äáº¿n khi cÃ³ 20 hoáº·c 30 conditional, thÃªm má»™t cÃ¡i ná»¯a khÃ´ng táº¡o ra khÃ¡c biá»‡t gÃ¬!"
>
> KhÃ´ng cÃ³ "simplifying force" tÃ¡c Ä‘á»™ng lÃªn code base ngoÃ i deliberate choice mÃ  báº¡n Ä‘Æ°a ra. Simplifying cáº§n effort, vÃ  má»i ngÆ°á»i thÆ°á»ng quÃ¡ vá»™i vÃ ng.
>
> *Cáº£m Æ¡n [Dan North](https://dannorth.net) vÃ¬ comment cá»§a anh áº¥y*.

Náº¿u báº¡n Ä‘Ã£ internalize mental model cá»§a project vÃ o long-term memory, báº¡n sáº½ khÃ´ng tráº£i qua cognitive load cao.

<div align="center">
  <img src="/img/mentalmodelsv15.png" alt="Mental models" width="700">
</div>

CÃ ng nhiá»u unique mental model Ä‘á»ƒ há»c, cÃ ng máº¥t nhiá»u thá»i gian Ä‘á»ƒ developer má»›i deliver value. Náº¿u báº¡n giá»¯ cognitive load tháº¥p, má»i ngÆ°á»i cÃ³ thá»ƒ contribute vÃ o codebase trong vÃ i giá» Ä‘áº§u khi join cÃ´ng ty. VÃ  Ä‘iá»u Ä‘Ã³ khÃ´ng cÃ³ nghÄ©a lÃ  ta hy sinh cháº¥t lÆ°á»£ng, hay cho phÃ©p pile of mud xuáº¥t hiá»‡n.

> CÃ¡c unique mental model Ä‘Ã³ lÃ  gÃ¬? ÄÃ³ lÃ  má»™t set rule, thÆ°á»ng lÃ  mixture cá»§a Clean Architecture/Event Driven Architecture/DDD. ÄÃ¢y lÃ  interpretation riÃªng cá»§a tÃ¡c giáº£ vá» nhá»¯ng thá»© khiáº¿n anh ta hÃ o há»©ng nháº¥t. Mental model chá»§ quan cá»§a riÃªng anh ta. **Extraneous cognitive load mÃ  ngÆ°á»i khÃ¡c pháº£i internalize.**

Khi báº¡n onboard ngÆ°á»i má»›i vÃ o project, hÃ£y thá»­ Ä‘o lÆ°á»ng lÆ°á»£ng confusion há» cÃ³ (pair programming cÃ³ thá»ƒ giÃºp). Náº¿u há» confused hÆ¡n ~40 phÃºt liÃªn tá»¥c - báº¡n cÃ³ thá»© cáº§n cáº£i thiá»‡n trong code.

## VÃ­ dá»¥
> Software system cÃ³ láº½ lÃ  thá»© phá»©c táº¡p nháº¥t vÃ  intricate nháº¥t (vá» sá»‘ lÆ°á»£ng loáº¡i part khÃ¡c nhau) mÃ  nhÃ¢n loáº¡i táº¡o ra.
>
> *Fred Brooks, The Mythical Man-Month*

- Architecture cá»§a chÃºng ta lÃ  standard CRUD app architecture, [má»™t Python monolith trÃªn Postgres](https://danluu.com/simple-architectures/)
- Instagram scale nhÆ° tháº¿ nÃ o tá»›i 14 triá»‡u user vá»›i [chá»‰ 3 engineer](https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million)
- CÃ¡c cÃ´ng ty nÆ¡i chÃºng ta "woah, nhá»¯ng ngÆ°á»i nÃ y [thÃ´ng minh vÃ£i](https://kenkantzer.com/learnings-from-5-years-of-tech-startup-code-audits/)" pháº§n lá»›n Ä‘Ã£ tháº¥t báº¡i
- Má»™t function wire up toÃ n bá»™ há»‡ thá»‘ng. Náº¿u báº¡n muá»‘n biáº¿t há»‡ thá»‘ng hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o - [Ä‘á»c nÃ³](https://www.infoq.com/presentations/8-lines-code-refactoring)
- Designing for Understandability: [The Raft Consensus Algorithm](https://www.youtube.com/watch?v=vYp4LYbnnW8)

CÃ¡c architecture nÃ y khÃ¡ nhÃ m chÃ¡n vÃ  dá»… hiá»ƒu. Báº¥t ká»³ ai cÅ©ng cÃ³ thá»ƒ grasp chÃºng mÃ  khÃ´ng cáº§n nhiá»u mental effort.

<details>
    <summary><b>NguyÃªn táº¯c coding vÃ  kinh nghiá»‡m</b></summary>
    <div align="center">
        <img src="img/complexity.png" alt="Super simple code" width="500">
    </div>
    <a href="https://twitter.com/flaviocopes">@flaviocopes</a>
</details>

Involve junior developer vÃ o architecture review, há» sáº½ giÃºp báº¡n identify cÃ¡c khu vá»±c mentally demanding.

**Maintaining software ráº¥t khÃ³**, má»i thá»© break vÃ  ta cáº§n má»i bit mental effort mÃ  ta cÃ³ thá»ƒ tiáº¿t kiá»‡m. CÃ ng Ã­t component trong há»‡ thá»‘ng, cÃ ng Ã­t issue sáº½ cÃ³. Debug cÅ©ng sáº½ Ã­t mentally taxing hÆ¡n.

> Debug khÃ³ gáº¥p Ä‘Ã´i so vá»›i viáº¿t code ngay tá»« Ä‘áº§u. Do Ä‘Ã³, náº¿u báº¡n viáº¿t code clever nháº¥t cÃ³ thá»ƒ, theo Ä‘á»‹nh nghÄ©a, báº¡n khÃ´ng Ä‘á»§ thÃ´ng minh Ä‘á»ƒ debug nÃ³.
>
> *Brian Kernighan*

NhÃ¬n chung, mindset "Wow, architecture nÃ y cháº¯c cháº¯n cáº£m tháº¥y tá»‘t!" ráº¥t misleading. ÄÃ³ lÃ  cáº£m giÃ¡c chá»§ quan "táº¡i má»™t thá»i Ä‘iá»ƒm", vÃ  nÃ³ khÃ´ng nÃ³i gÃ¬ vá» thá»±c táº¿. Approach tá»‘t hÆ¡n nhiá»u lÃ  quan sÃ¡t háº­u quáº£ vá» lÃ¢u dÃ i:
- CÃ³ dá»… reproduce vÃ  debug issue khÃ´ng? Hay báº¡n pháº£i nháº£y qua call stack hoáº·c distributed component, cá»‘ gáº¯ng hiá»ƒu má»i thá»© trong Ä‘áº§u?
- Ta cÃ³ thá»ƒ thay Ä‘á»•i nhanh khÃ´ng, hay cÃ³ nhiá»u unknown unknown, vÃ  má»i ngÆ°á»i sá»£ touch má»i thá»©?
- NgÆ°á»i má»›i cÃ³ thá»ƒ add feature nhanh khÃ´ng? CÃ³ unique mental model nÃ o cáº§n há»c khÃ´ng?

Nhá»¯ng cÃ¢u há»i nÃ y khÃ³ track hÆ¡n nhiá»u, vÃ  má»i ngÆ°á»i thÆ°á»ng khÃ´ng thÃ­ch tráº£ lá»i chÃºng trá»±c tiáº¿p. NhÃ¬n vÃ o má»™t vÃ i software system phá»©c táº¡p nháº¥t tháº¿ giá»›i, nhá»¯ng thá»© Ä‘Ã£ vÆ°á»£t qua thá»­ thÃ¡ch cá»§a thá»i gian - Unix, Kubernetes, Chrome vÃ  Redis (xem comment bÃªn dÆ°á»›i). Báº¡n sáº½ khÃ´ng tÃ¬m tháº¥y gÃ¬ fancy á»Ÿ Ä‘Ã³, pháº§n lá»›n lÃ  nhÃ m chÃ¡n, vÃ  Ä‘Ã³ lÃ  Ä‘iá»u tá»‘t.

## Káº¿t luáº­n
TÆ°á»Ÿng tÆ°á»£ng má»™t chá»‘c ráº±ng cÃ¡i mÃ  ta suy ra trong chÆ°Æ¡ng thá»© hai thá»±c ra khÃ´ng Ä‘Ãºng. Náº¿u váº­y, thÃ¬ káº¿t luáº­n mÃ  ta vá»«a phá»§ Ä‘á»‹nh, cÃ¹ng vá»›i cÃ¡c káº¿t luáº­n trong chÆ°Æ¡ng trÆ°á»›c mÃ  ta Ä‘Ã£ cháº¥p nháº­n lÃ  há»£p lá»‡, cÃ³ thá»ƒ khÃ´ng chÃ­nh xÃ¡c. `ğŸ¤¯`

Báº¡n cáº£m tháº¥y nÃ³ chá»©? KhÃ´ng chá»‰ báº¡n pháº£i nháº£y kháº¯p bÃ i Ä‘á»ƒ láº¥y nghÄ©a (shallow module!), mÃ  Ä‘oáº¡n vÄƒn nÃ³i chung khÃ³ hiá»ƒu. ChÃºng ta vá»«a táº¡o ra unnecessary cognitive load trong Ä‘áº§u báº¡n. **Äá»«ng lÃ m Ä‘iá»u nÃ y vá»›i Ä‘á»“ng nghiá»‡p.**

<div align="center">
  <img src="/img/smartauthorv14thanksmari.png" alt="Smart author" width="600">
</div>

ChÃºng ta nÃªn giáº£m báº¥t ká»³ cognitive load nÃ o ngoÃ i cÃ¡i vá»‘n cÃ³ trong cÃ´ng viá»‡c chÃºng ta lÃ m.

---
[LinkedIn](https://www.linkedin.com/in/zakirullin/), [X](https://twitter.com/zakirullin), [GitHub](https://github.com/zakirullin), artemzr(Ğ°t)g-yĞ¾u-knĞ¾w-com

<details>
    <summary><b>Comment</b></summary>
    <br>
    <p><strong>Rob Pike</strong> <i>(Unix, Golang)</i><br>BÃ i viáº¿t hay.</p>
    <p><strong><a href="https://x.com/karpathy/status/1872038630405054853" target="_blank">Andrej Karpathy</a></strong> <i>(ChatGPT, Tesla)</i><br>BÃ i post hay vá» software engineering. CÃ³ láº½ lÃ  quan Ä‘iá»ƒm Ä‘Ãºng nháº¥t, Ä‘Æ°á»£c thá»±c hÃ nh Ã­t nháº¥t.</p>
    <p><strong><a href="https://x.com/elonmusk/status/1872346903792566655" target="_blank">Elon Musk</a></strong> <i>(Rocket)</i><br>ÄÃºng.</p>
    <p><strong><a href="https://www.linkedin.com/feed/update/urn:li:activity:7277757844970520576/" target="_blank">Addy Osmani</a></strong> <i>(Chrome, software system phá»©c táº¡p nháº¥t tháº¿ giá»›i)</i><br>TÃ´i Ä‘Ã£ tháº¥y vÃ´ sá»‘ project nÆ¡i developer thÃ´ng minh táº¡o ra architecture áº¥n tÆ°á»£ng báº±ng design pattern má»›i nháº¥t vÃ  microservice. NhÆ°ng khi team member má»›i cá»‘ gáº¯ng thay Ä‘á»•i, há» máº¥t hÃ ng tuáº§n chá»‰ Ä‘á»ƒ hiá»ƒu má»i thá»© fit vá»›i nhau nhÆ° tháº¿ nÃ o. Cognitive load cao Ä‘áº¿n ná»—i productivity giáº£m máº¡nh vÃ  bug nhÃ¢n lÃªn.</p>
    <p>Má»‰a mai? Nhiá»u pattern gÃ¢y complexity nÃ y Ä‘Æ°á»£c implement vá»›i danh nghÄ©a "clean code."</p>
    <p>Äiá»u thá»±c sá»± quan trá»ng lÃ  giáº£m unnecessary cognitive burden. ÄÃ´i khi Ä‘iá»u nÃ y cÃ³ nghÄ©a lÃ  Ã­t module sÃ¢u hÆ¡n thay vÃ¬ nhiá»u shallow module. ÄÃ´i khi cÃ³ nghÄ©a lÃ  giá»¯ logic liÃªn quan vá»›i nhau thay vÃ¬ tÃ¡ch thÃ nh cÃ¡c function nhá».</p>
    <p>VÃ  Ä‘Ã´i khi cÃ³ nghÄ©a lÃ  chá»n solution nhÃ m chÃ¡n, straightforward hÆ¡n lÃ  clever. Code tá»‘t nháº¥t khÃ´ng pháº£i elegant hoáº·c sophisticated nháº¥t - Ä‘Ã³ lÃ  code mÃ  developer tÆ°Æ¡ng lai (bao gá»“m cáº£ báº¡n) cÃ³ thá»ƒ hiá»ƒu nhanh chÃ³ng.</p>
    <p>BÃ i viáº¿t cá»§a báº¡n thá»±c sá»± cá»™ng hÆ°á»Ÿng vá»›i cÃ¡c challenge chÃºng tÃ´i Ä‘á»‘i máº·t trong browser development. Báº¡n hoÃ n toÃ n Ä‘Ãºng vá» browser hiá»‡n Ä‘áº¡i lÃ  má»™t trong nhá»¯ng software system phá»©c táº¡p nháº¥t. Quáº£n lÃ½ complexity Ä‘Ã³ trong Chromium lÃ  challenge liÃªn tá»¥c align hoÃ n háº£o vá»›i nhiá»u Ä‘iá»ƒm báº¡n Ä‘Æ°a ra vá» cognitive load.</p>
    <p>Má»™t cÃ¡ch chÃºng tÃ´i cá»‘ gáº¯ng handle Ä‘iá»u nÃ y trong Chromium lÃ  thÃ´ng qua component isolation cáº©n tháº­n vÃ  well-defined interface giá»¯a cÃ¡c subsystem (nhÆ° rendering, networking, JavaScript execution, v.v.). TÆ°Æ¡ng tá»± vÃ­ dá»¥ deep module cá»§a báº¡n vá»›i Unix I/O - chÃºng tÃ´i aim cho powerful functionality Ä‘áº±ng sau interface tÆ°Æ¡ng Ä‘á»‘i Ä‘Æ¡n giáº£n. VÃ­ dá»¥, rendering pipeline cá»§a chÃºng tÃ´i handle incredible complexity (layout, compositing, GPU acceleration) nhÆ°ng developer cÃ³ thá»ƒ tÆ°Æ¡ng tÃ¡c vá»›i nÃ³ thÃ´ng qua clear abstraction layer.</p>
    <p>CÃ¡c Ä‘iá»ƒm cá»§a báº¡n vá» trÃ¡nh unnecessary abstraction cÅ©ng ráº¥t trÃºng. Trong browser development, chÃºng tÃ´i liÃªn tá»¥c cÃ¢n báº±ng giá»¯a lÃ m codebase approachable cho contributor má»›i trong khi handle inherent complexity cá»§a web standard vÃ  compatibility.</p>
    <p>ÄÃ´i khi solution Ä‘Æ¡n giáº£n nháº¥t lÃ  tá»‘t nháº¥t, ngay cáº£ trong complex system.</p>
    <p><strong><a href="https://x.com/antirez" target="_blank">antirez</a></strong> <i>(Redis)</i><br>HoÃ n toÃ n Ä‘á»“ng Ã½ :) NgoÃ i ra, cÃ¡i tÃ´i tin lÃ  thiáº¿u trong "A Philosophy of Software Design" Ä‘Ã£ Ä‘á» cáº­p lÃ  khÃ¡i niá»‡m "design sacrifice". Tá»©c lÃ , Ä‘Ã´i khi báº¡n sacrifice thá»© gÃ¬ Ä‘Ã³ vÃ  nháº­n láº¡i simplicity, hoáº·c performance, hoáº·c cáº£ hai. TÃ´i Ã¡p dá»¥ng Ã½ tÆ°á»Ÿng nÃ y liÃªn tá»¥c, nhÆ°ng thÆ°á»ng khÃ´ng Ä‘Æ°á»£c hiá»ƒu.</p>
    <p>Má»™t vÃ­ dá»¥ tá»‘t lÃ  viá»‡c tÃ´i luÃ´n tá»« chá»‘i cÃ³ hash item expire. ÄÃ¢y lÃ  design sacrifice vÃ¬ náº¿u báº¡n cÃ³ certain attribute chá»‰ trong top-level item (cÃ¡c key chÃ­nh chÃºng), thiáº¿t káº¿ Ä‘Æ¡n giáº£n hÆ¡n, value sáº½ chá»‰ lÃ  object. Khi Redis cÃ³ hash expire, Ä‘Ã³ lÃ  nice feature nhÆ°ng yÃªu cáº§u (tháº­t váº­y) nhiá»u thay Ä‘á»•i cho nhiá»u part, tÄƒng complexity.</p>
    <p>Má»™t vÃ­ dá»¥ khÃ¡c lÃ  cÃ¡i tÃ´i Ä‘ang lÃ m ngay bÃ¢y giá», Vector Set, Redis data type má»›i. TÃ´i quyáº¿t Ä‘á»‹nh ráº±ng Redis sáº½ khÃ´ng lÃ  source of truth vá» vector, mÃ  nÃ³ chá»‰ cÃ³ thá»ƒ láº¥y approximate version cá»§a chÃºng, nÃªn tÃ´i cÃ³ thá»ƒ lÃ m on-insert normalization, quantization mÃ  khÃ´ng cá»‘ gáº¯ng retain large float vector trÃªn disk, v.v. Nhiá»u vector DB khÃ´ng sacrifice viá»‡c nhá»› cÃ¡i user Ä‘Æ°a vÃ o (full precision vector).</p>
    <p>ÄÃ¢y chá»‰ lÃ  hai vÃ­ dá»¥ random, nhÆ°ng tÃ´i Ã¡p dá»¥ng Ã½ tÆ°á»Ÿng nÃ y á»Ÿ má»i nÆ¡i. BÃ¢y giá» váº¥n Ä‘á» lÃ : dÄ© nhiÃªn ngÆ°á»i ta pháº£i sacrifice Ä‘Ãºng thá»©. ThÆ°á»ng cÃ³ 5% feature chiáº¿m very large amount cá»§a complexity: Ä‘Ã³ lÃ  thá»© tá»‘t Ä‘á»ƒ kill :D</p>
    <p><strong><a href="https://working-for-the-future.medium.com/about" target="_blank">Má»™t developer tá»« internet</a></strong><br>Báº¡n sáº½ khÃ´ng hire tÃ´i... TÃ´i bÃ¡n mÃ¬nh dá»±a trÃªn track record cá»§a cÃ¡c enterprise project Ä‘Ã£ release.</p>
    <p>TÃ´i lÃ m viá»‡c vá»›i má»™t ngÆ°á»i cÃ³ thá»ƒ nÃ³i vá» design pattern. TÃ´i khÃ´ng bao giá» cÃ³ thá»ƒ nÃ³i kiá»ƒu Ä‘Ã³, máº·c dÃ¹ tÃ´i lÃ  má»™t trong sá»‘ Ã­t cÃ³ thá»ƒ hiá»ƒu anh ta rÃµ rÃ ng. CÃ¡c manager yÃªu thÃ­ch anh ta vÃ  anh ta cÃ³ thá»ƒ dominate báº¥t ká»³ development conversation nÃ o. Nhá»¯ng ngÆ°á»i lÃ m viá»‡c xung quanh anh ta nÃ³i anh ta Ä‘á»ƒ láº¡i trail of destruction phÃ­a sau. NgÆ°á»i ta nÃ³i vá»›i tÃ´i ráº±ng tÃ´i lÃ  ngÆ°á»i Ä‘áº§u tiÃªn cÃ³ thá»ƒ hiá»ƒu project cá»§a anh ta. Maintainability quan trá»ng. TÃ´i quan tÃ¢m nháº¥t vá» TCO (<i>Total Cost of Ownership</i>). Vá»›i má»™t vÃ i firm, Ä‘Ã³ lÃ  thá»© quan trá»ng.</p>
    <p>TÃ´i Ä‘Äƒng nháº­p Github sau khi khÃ´ng á»Ÿ Ä‘Ã³ má»™t thá»i gian vÃ  vÃ¬ lÃ½ do nÃ o Ä‘Ã³ nÃ³ Ä‘Æ°a tÃ´i Ä‘áº¿n má»™t bÃ i trong repository cá»§a ai Ä‘Ã³ cÃ³ váº» random. TÃ´i nghÄ© "cÃ¡i gÃ¬ Ä‘Ã¢y" vÃ  gáº·p chÃºt ráº¯c rá»‘i Ä‘á»ƒ Ä‘áº¿n home page, nÃªn tÃ´i Ä‘á»c nÃ³. TÃ´i khÃ´ng thá»±c sá»± register nÃ³ vÃ o lÃºc Ä‘Ã³, nhÆ°ng nÃ³ tuyá»‡t vá»i. Má»i developer nÃªn Ä‘á»c nÃ³. NÃ³ pháº§n lá»›n nÃ³i ráº±ng háº§u nhÆ° má»i thá»© chÃºng ta Ä‘Æ°á»£c nÃ³i vá» programming best practice dáº«n Ä‘áº¿n "cognitive load" quÃ¡ má»©c, cÃ³ nghÄ©a lÃ  Ä‘áº§u Ã³c cá»§a chÃºng ta bá»‹ Ä‘Ã¡ bá»Ÿi intellectual demand. TÃ´i Ä‘Ã£ biáº¿t Ä‘iá»u nÃ y má»™t thá»i gian, Ä‘áº·c biá»‡t vá»›i cÃ¡c demand cá»§a cloud, security vÃ  DevOps.</p>
    <p>TÃ´i cÅ©ng thÃ­ch nÃ³ vÃ¬ nÃ³ mÃ´ táº£ practice tÃ´i lÃ m trong hÃ ng tháº­p ká»·, nhÆ°ng khÃ´ng bao giá» thá»«a nháº­n vÃ¬ chÃºng khÃ´ng popular... TÃ´i viáº¿t stuff thá»±c sá»± phá»©c táº¡p vÃ  cáº§n má»i help tÃ´i cÃ³ thá»ƒ nháº­n Ä‘Æ°á»£c.</p>
    <p>CÃ¢n nháº¯c, náº¿u tÃ´i Ä‘Ãºng, nÃ³ pop up vÃ¬ cÃ¡c Github folk, nhá»¯ng ngÆ°á»i ráº¥t thÃ´ng minh, nghÄ© ráº±ng developer nÃªn tháº¥y nÃ³. TÃ´i Ä‘á»“ng Ã½.</p>
    <p><a href="https://news.ycombinator.com/item?id=45074248" target="_blank">Comment trÃªn Hacker News</a> (<a href="https://news.ycombinator.com/item?id=42489645" target="_blank">2</a>)</p>
</details>
